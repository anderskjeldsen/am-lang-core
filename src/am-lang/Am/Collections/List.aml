namespace Am.Collections {

    class CoreStartup {
        import Am.Lang
        import Am.IO
        import Am.IO.Networking

        static fun main() {
            var set = new HashSet<String>()

            var i = 1
            var max = 10000000
            ("Adding " + max.toString() + " key-value pairs to a HashSet on an emulated 020").println()
            while(i <= max) {                
                var value = i.toString()
                set.add(value)
                i++
            }
            var testVal = "4"
            var iset = set as Set<String>
            var hasValue = iset.has(testVal)

            if (hasValue) {
                "found".println()
            } else {
                "not found".println()
            }
        }

        static fun main4() {
            var map = new HashMap<String, String>()

            var i = 1
            "Adding 1000 key-value pairs to a hash map on an emulated 020".println()
            while(i <= 1000) {                
                var key = i.toString()
                var value = (i + 1).toString()
                map.set(key, value)
                if (i % 100 == 0) {
                    "Added another 100".println()
                }
                i++
            }

            CoreStartup.printValue(map, "213")
            CoreStartup.printValue(map, "500")
            CoreStartup.printValue(map, "750")
            CoreStartup.printValue(map, "1000")
        }

        static fun printValue(map: HashMap<String, String>, key: String) {
            var s = map.get(key)
            ("Value of key " + key + ", should be " + key + "+1: " + s).println()
        }

        static fun main3() {
            var list = List<String>.newList<String>()
            list.add("hello")
            list.add("world")
            each(list, i) {
                i.println()
            }
        }

        static fun main2() {
            "connect to localhost".println()
            var s = Socket.create(AddressFamily.inet, SocketType.stream, ProtocolFamily.unspecified)
            s.connect("localhost", 9030)
            "connected".println()

            var socketStream = new SocketStream(s)
            var istream = socketStream as Stream
            var ts = new TextStream(istream)
            ts.writeString("GET / HTTP/1.1\r\nHost:localhost\r\n\r\n")

            var rs = ts.readString()
            rs.println()        
            s.close()    
        }
/*
        static fun main6() {
            var host = "www.kelson.no"
            ("connect to " + host).println()
            var s = Socket.create(AddressFamily.inet, SocketType.stream, ProtocolFamily.unspecified)
            s.connect(host, 443)
            "connected".println()

            var sslCert = SslCert.load("cacert.pem")

            var socketStream = new SslSocketStream(s, host, sslCert)
            var istream = socketStream as Stream
            var ts = new TextStream(istream)
            ts.writeString("GET / HTTP/1.1\r\nHost: " + host + "\r\n\r\n")

            var rs = ts.readString()
            "data read".println()
            rs.println()        
            s.close()    
            "closed".println()
        }
*/

    }
    class List<T>: Iterable<T> {
        import Am.Lang

        private var size: Int = 0
        var capacity: Int = 0
        private var items: T[]

        static fun newList<T>(): List<T> {
            var l: List<T> = new List<T>()
            l.capacity = 2
            l.items = new T[l.capacity]
            return l
        }

        fun addArray(items: T[]) {
            var x = 0
            while(x < items.length()) {
                this.add(items[x])
                x++
            }
        }

        fun getSize(): Int {
            return this.size
        }

        fun add(item: T) {
//            if (item !=  null) {
                if (this.size >= this.capacity) {
                    var newCapacity = this.capacity * 150
                    newCapacity = newCapacity / 100
                    var newItems = new T[newCapacity]
                    var x = 0
                    while(x < this.size) {
                        newItems[x] = this.items[x]                    
                        x++
                    }
                    this.capacity = newCapacity // bla
                    this.items = newItems
                }
                if (this.size < this.capacity ) {
                    this.items[this.size] = item
                    this.size++
                }
//           }
        }

        fun remove(item: T) {
//            if (item != null) {
                var i = 0
                while(i < this.size) {
                    var x = this.items[i]
                    if (x == item) {
                        while(i < this.size) {
                            this.items[i] = this.items[i + 1]
                            i++
                        }
                        this.size--
                    }
                    i++
                }
//            }
        }

        fun get(index: Int): T {
            if (index < 0 || index > this.size) {
                throw new Exception("Index out of bounds: " + index.toString())                
            }
            return this.items[index]
        }

        fun toArray(): T[] {
            var arr = new T[this.size]
            var i = 0
            while(i < this.size) {
                arr[i] = this.get(i)
                i++
            }
            return arr
        }

        fun iterator(): Iterator<T> {
            var x = new ListIterator<T>(this)
            var y = x as Iterator<T>
            return y
        }
    }
}