namespace Am.Collections {

    class HashSet2<T>: Set<T> {
        import Am.Lang

        private var size: Int
        private var currentValueIndex: Int
        private var nextIndexes: Int[]
        private var valueIndexes: Int[]
        private var values: T[] 
        private var bucketSize: Int
        private var currentIndex: Int

        fun getSize(): Int {
            return this.size
        }

        fun has(value: T): Bool {
            "has value".println()
            if (this.valueIndexes == null) {
                return false
            }
            var hash = value.hash()
            var index = hash % this.bucketSize
            var x = this.findEntry(index, value)
            if (x >= 0) {
                return true
            }
            return false
        }

        private fun findEntry(index: Int, value: T): Int {
            while(index > -1) {
//                ("check index " + index.toString()).println()
                var valueIndex = this.valueIndexes[index] - 1
//                ("value index: " + valueIndex.toString()).println()
                var value2 = this.values[valueIndex]
//                ("value: " + value2.toString()).println()
                if (value2 == value) {
//                    "found it".println()
                    return valueIndex
                }
                index = this.nextIndexes[index] - 1                
            }
            return -1
        }

        fun add(value: T) {
            if (this.nextIndexes == null) {
                this.bucketSize = 20
                this.nextIndexes = new Int[this.bucketSize * 2]
                this.values = new T[this.bucketSize]
                this.valueIndexes = new Int[this.bucketSize * 2]
                this.currentIndex = this.bucketSize
            }

            if ( this.size * 4 >= this.bucketSize * 3 || this.currentIndex >= (this.bucketSize * 2) ) {
                var valueLastIndex = this.currentValueIndex
                var oldValues = this.values
                var newBucketSize = this.bucketSize * 10
                this.bucketSize = newBucketSize
                this.currentIndex = newBucketSize
                this.currentValueIndex = 0
                this.size = 0

                this.nextIndexes = new Int[newBucketSize * 2]
                this.values = new T[newBucketSize]
                this.valueIndexes = new Int[newBucketSize * 2]
//                ("create new bucket in HashSet: " + this.bucketSize.toString() + ", copy " + valueLastIndex.toString() + " items").println()

                var i = 0
                while(i < valueLastIndex) {
                    var oldValue = oldValues[i]
                    this.privateSetValue(oldValue)
                    i++
                }       
            }

            this.privateSetValue(value)
        }

        private fun privateSetValue(value: T) {
            var hash = value.hash()
            var index = hash % this.bucketSize
//            ("value: " + value.toString() + ", hash: " + hash.toString() + ", index: " + index.toString()).println()

//            ("set 1b" + this.currentValueIndex.toString()).println()
            this.values[this.currentValueIndex] = value

            var valueIndex = this.valueIndexes[index] - 1

            if (valueIndex < 0) {
//                "make new hash entry".println()

                this.valueIndexes[index] = this.currentValueIndex + 1 // cause all are initially set to 0, then a real 0 will be 1
                this.nextIndexes[index] = 0
                this.size++            
            } 
            else {                  
//                ("push old hash entry: " + value.toString()).println()
//                ("push old valueIndex: " + valueIndex.toString()).println()
                this.valueIndexes[this.currentIndex] = valueIndex + 1 // append new index to the value at the end
//                ("push old nextIndex: " + this.nextIndexes[index].toString()).println()
                this.nextIndexes[this.currentIndex] = this.nextIndexes[index] // append new index to the next value at the end

//                ("set new valueIndex: " + (this.currentValueIndex + 1).toString()).println()
                this.valueIndexes[index] = this.currentValueIndex + 1
//                ("set new nextIndex: " + (this.currentIndex + 1).toString()).println()
                this.nextIndexes[index] = this.currentIndex + 1
                this.currentIndex++
                this.size++
            }
            this.currentValueIndex++
        }
    }
}