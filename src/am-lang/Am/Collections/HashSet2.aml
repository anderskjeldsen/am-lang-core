namespace Am.Collections {

    class HashSet<T>: Set<T> {
        import Am.Lang

        private var size: Int
        private var currentValueIndex: Int
        private var nextIndexes: Int[]
        private var valueIndexes: Int[]
        private var values: T[] 
        private var bucketSize: Int
        private var currentIndex: Int

        fun getSize(): Int {
            return this.size
        }

        fun has(value: T): Bool {
            "has value".println()
            if (this.valueIndexes == null) {
                return false
            }
            var hash = value.hash()
            var index = hash % this.bucketSize
            var valueIndex = this.valueIndexes[index] - 1
            var x = this.findEntry(valueIndex, value)
            if (x >= 0) {
                return true
            }
            return false
        }

        private fun findEntry(valueIndex: Int, value: T): Int {
            while(valueIndex > -1) {
//                var valueIndex = this.valueIndexes[index] - 1
                var value2 = this.values[valueIndex]
                if (value2 == value) {
                    return valueIndex
                }
                valueIndex = this.nextIndexes[valueIndex] - 1                
            }
            return -1
        }

        fun add(value: T) {
            if (this.nextIndexes == null) {
                this.bucketSize = 100
                this.nextIndexes = new Int[this.bucketSize]
                this.values = new T[this.bucketSize]
                this.valueIndexes = new Int[this.bucketSize * 2]
                this.currentIndex = this.bucketSize
            }

            if ( this.size * 4 >= this.bucketSize * 2 || this.currentIndex >= (this.bucketSize * 2) ) {
                var valueLastIndex = this.currentValueIndex
                var oldValues = this.values
                var newBucketSize = this.bucketSize * 10
                this.bucketSize = newBucketSize
                this.currentIndex = newBucketSize
                this.currentValueIndex = 0
                this.size = 0

                this.nextIndexes = new Int[newBucketSize]
                this.values = new T[newBucketSize]
                this.valueIndexes = new Int[newBucketSize * 2]
                ("create new bucket in HashSet: " + this.bucketSize.toString() + ", copy " + valueLastIndex.toString() + " items").println()

                var i = 0
                while(i < valueLastIndex) {
                    var oldValue = oldValues[i]
                    this.privateSetValue(oldValue)
                    i++
                }       
            }

            this.privateSetValue(value)
        }

        private fun privateSetValue(value: T) {
            var hash = value.hash()
            var index = hash % this.bucketSize

            this.values[this.currentValueIndex] = value
//            this.nextIndexes[this.currentValueIndex] = 0

            var valueIndex = this.valueIndexes[index] - 1 // index of values and next arrays

            if (valueIndex < 0) {
                this.valueIndexes[index] = this.currentValueIndex + 1 // cause all are initially set to 0, then a real 0 will be 1
                this.nextIndexes[this.currentValueIndex] = 0
                this.size++            
            } 
            else {        
//                {v: x, n: 0}          
//              {v: y, n: x}
//                this.valueIndexes[this.currentIndex] = valueIndex + 1 // append new index to the value at the end
//                this.nextIndexes[this.currentValueIndex] = this.nextIndexes[valueIndex] // append new index to the next value at the end

                this.valueIndexes[index] = this.currentValueIndex + 1
                this.nextIndexes[this.currentValueIndex] = valueIndex + 1 // old value
                this.currentIndex++
                this.size++
            }
            this.currentValueIndex++
        }
        fun contains(value: T): Bool {
            return this.has(value)
        }

        fun remove(value: T): Bool {
            if (this.valueIndexes == null) {
                return false
            }
            var hash = value.hash()
            var index = hash % this.bucketSize
            var valueIndex = this.valueIndexes[index] - 1
            
            if (valueIndex < 0) {
                return false
            }
            
            // Check if it's the first item in the chain
            var firstValue = this.values[valueIndex]
            if (firstValue == value) {
                // Remove first item - update bucket to point to next
                var nextIndex = this.nextIndexes[valueIndex] - 1
                if (nextIndex >= 0) {
                    this.valueIndexes[index] = nextIndex + 1
                } else {
                    this.valueIndexes[index] = 0
                }
                this.size--
                return true
            }
            
            // Look for item in the chain
            var previousIndex = valueIndex
            valueIndex = this.nextIndexes[valueIndex] - 1
            while(valueIndex > -1) {
                var value2 = this.values[valueIndex]
                if (value2 == value) {
                    // Remove item by updating previous to point to next
                    var nextIndex = this.nextIndexes[valueIndex] - 1
                    if (nextIndex >= 0) {
                        this.nextIndexes[previousIndex] = nextIndex + 1
                    } else {
                        this.nextIndexes[previousIndex] = 0
                    }
                    this.size--
                    return true
                }
                previousIndex = valueIndex
                valueIndex = this.nextIndexes[valueIndex] - 1
            }
            return false
        }

        fun clear() {
            this.size = 0
            this.currentValueIndex = 0
            this.currentIndex = this.bucketSize
            if (this.valueIndexes != null) {
                var i = 0
                while(i < this.valueIndexes.length()) {
                    this.valueIndexes[i] = 0
                    i++
                }
            }
        }

        fun toArray(): T[] {
            if (this.size == 0) {
                return new T[0]
            }
            var arr = new T[this.size]
            var arrIndex = 0
            var i = 0
            while(i < this.currentValueIndex && arrIndex < this.size) {
                // Check if this value is still valid (not removed)
                var value = this.values[i]
                if (this.has(value)) {
                    arr[arrIndex] = value
                    arrIndex++
                }
                i++
            }
            return arr
        }
    }
}