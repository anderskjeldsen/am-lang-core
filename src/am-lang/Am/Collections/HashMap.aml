namespace Am.Collections {

    class HashMapEntry<K, V>(var key: K, var value: V): MapEntry<K, V> {
        var next: HashMapEntry<K, V>
        fun getKey(): K {
            return this.key
        }
        fun getValue(): V {
            return this.value
        }
    }

    class HashMap_old<K, V>: Map<K, V> {
        import Am.Lang

        private var size: Int
        private var bucket: HashMapEntry<K, V>[]

        static fun createWithInitialSize<K, V>(initialSize: Int): HashMap_old<K, V> {
            var map = new HashMap_old<K, V>()
            map.size = initialSize
            map.bucket = new HashMapEntry<K, V>[initialSize]
            return map
        }

        fun getSize(): Int {
            return this.size
        }

        fun get(key: K): V {
            if (this.bucket == null) {
                return null
            }
            var hash = key.hash()
            var index = hash % this.bucket.length()

            var entry = this.bucket[index]
            var res = this.findEntry(entry, key)
            if (res != null) {
                return res.value
            }
            return null
        }

        private fun findEntry(entry: HashMapEntry<K, V>, key: K): HashMapEntry<K, V> {
            while(entry != null) {
                if (entry.key == key) {
                    return entry
                }
                entry = entry.next
            }
            return null
        }

        fun set(key: K, value: V) {
            if (this.bucket == null) {
                this.bucket = new HashMapEntry<K, V>[20]
            }

            if (this.size > (this.bucket.length())) {
                var oldBucket = this.bucket
                this.bucket = new HashMapEntry<K, V>[this.bucket.length() * 10UI]
                ("create new bucket in HashMap: " + this.bucket.length().toString()).println()

                var i = 0
                var n: HashMapEntry<K, V> = null
                while(i < oldBucket.length()) {
                    var entry = oldBucket[i]
                    while (entry != null) {    
                        var next = entry.next
                        entry.next = n
                        this.privateSetEntry(entry)
                        entry = next
                    }
                    i++
                }       
            }

            this.privateSet(key, value)
        }

        private fun privateSetEntry(entry: HashMapEntry<K, V>) {
            var hash = entry.key.hash()
            var index = hash % this.bucket.length()

            var bEntry = this.bucket[index]
            if (bEntry == null) {
                this.bucket[index] = entry
            } 
            else {                
                this.bucket[index] = entry
                entry.next = bEntry
            }
        }

        private fun privateSet(key: K, value: V) {
            var hash = key.hash()
            var index = hash % this.bucket.length()

            var entry = this.bucket[index]
            if (entry == null) {
                entry = new HashMapEntry<K, V>(key, value)
                this.bucket[index] = entry
                this.size++
            } 
            else {
                var found = false
                var previous = entry
                while((entry != null) && (found == false)) {
                    previous = entry
                    if (key == entry.key) {
                        found = true
                    }
                    entry = entry.next
                }
                if (!found) {
                    previous.next = new HashMapEntry<K, V>(key, value)
                    this.size++
                }
            }

        }

        fun remove(key: K): V {
            return null
        }

        fun clear() {
        }

        fun containsKey(key: K): Bool {
            return false
        }

        fun containsValue(value: V): Bool {
            return false
        }
    }

    class HashMap<K, V>: Map<K, V> {
        import Am.Lang

        private var size: Int
        private var currentEntryIndex: Int
        private var nextIndexes: Int[]
        private var keyIndexes: Int[]
        private var keys: K[]
        private var values: V[] 
        private var bucketSize: Int
        private var currentIndex: Int

        static fun createWithInitialSize<K, V>(initialSize: Int): HashMap<K, V> {
            var map = new HashMap<K, V>()
            map.bucketSize = initialSize
            map.currentIndex = initialSize
            map.nextIndexes = new Int[initialSize]
            map.keys = new K[initialSize]
            map.values = new V[initialSize]
            map.keyIndexes = new Int[initialSize * 2]
            return map
        }

        fun getSize(): Int {
            return this.size
        }

        fun get(key: K): V {
            if (this.keyIndexes == null) {
                return null
            }
            var hash = key.hash()
            var index = hash % this.bucketSize
            var keyIndex = this.keyIndexes[index] - 1
            var entryIndex = this.findEntry(keyIndex, key)
            if (entryIndex >= 0) {
                return this.values[entryIndex]
            }
            return null
        }

        private fun findEntry(keyIndex: Int, key: K): Int {
            while(keyIndex > -1) {
                var key2 = this.keys[keyIndex]
                if (key2 == key) {
                    return keyIndex
                }
                keyIndex = this.nextIndexes[keyIndex] - 1                
            }
            return -1
        }

        fun set(key: K, value: V) {
            if (this.nextIndexes == null) {
                this.bucketSize = 100
                this.nextIndexes = new Int[this.bucketSize]
                this.keys = new K[this.bucketSize]
                this.values = new V[this.bucketSize]
                this.keyIndexes = new Int[this.bucketSize * 2]
                this.currentIndex = this.bucketSize
            }

            if ( this.size * 4 >= this.bucketSize * 2 || this.currentIndex >= (this.bucketSize * 2) ) {
                var entryLastIndex = this.currentEntryIndex
                var oldKeys = this.keys
                var oldValues = this.values
                var newBucketSize = this.bucketSize * 10
                this.bucketSize = newBucketSize
                this.currentIndex = newBucketSize
                this.currentEntryIndex = 0
                this.size = 0

                this.nextIndexes = new Int[newBucketSize]
                this.keys = new K[newBucketSize]
                this.values = new V[newBucketSize]
                this.keyIndexes = new Int[newBucketSize * 2]
                ("create new bucket in HashMap: " + this.bucketSize.toString() + ", copy " + entryLastIndex.toString() + " items").println()

                var i = 0
                while(i < entryLastIndex) {
                    var oldKey = oldKeys[i]
                    var oldValue = oldValues[i]
                    this.privateSetKeyValue(oldKey, oldValue)
                    i++
                }       
            }

            this.privateSetKeyValue(key, value)
        }

        private fun privateSetKeyValue(key: K, value: V) {
            var hash = key.hash()
            var index = hash % this.bucketSize

            // Check if key already exists
            var keyIndex = this.keyIndexes[index] - 1
            var existingIndex = this.findEntry(keyIndex, key)
            if (existingIndex >= 0) {
                // Update existing value
                this.values[existingIndex] = value
                return
            }

            this.keys[this.currentEntryIndex] = key
            this.values[this.currentEntryIndex] = value

            keyIndex = this.keyIndexes[index] - 1 // index of keys and next arrays

            if (keyIndex < 0) {
                this.keyIndexes[index] = this.currentEntryIndex + 1 // cause all are initially set to 0, then a real 0 will be 1
                this.nextIndexes[this.currentEntryIndex] = 0
                this.size++            
            } 
            else {        
                this.keyIndexes[index] = this.currentEntryIndex + 1
                this.nextIndexes[this.currentEntryIndex] = keyIndex + 1 // old value
                this.currentIndex++
                this.size++
            }
            this.currentEntryIndex++
        }

        fun remove(key: K): V {
            if (this.keyIndexes == null) {
                return null
            }
            var hash = key.hash()
            var index = hash % this.bucketSize
            var keyIndex = this.keyIndexes[index] - 1
            
            if (keyIndex < 0) {
                return null
            }
            
            // Check if it's the first item in the chain
            var firstKey = this.keys[keyIndex]
            if (firstKey == key) {
                var oldValue = this.values[keyIndex]
                // Remove first item - update bucket to point to next
                var nextIndex = this.nextIndexes[keyIndex] - 1
                if (nextIndex >= 0) {
                    this.keyIndexes[index] = nextIndex + 1
                } else {
                    this.keyIndexes[index] = 0
                }
                this.size--
                return oldValue
            }
            
            // Look for item in the chain
            var previousIndex = keyIndex
            keyIndex = this.nextIndexes[keyIndex] - 1
            while(keyIndex > -1) {
                var key2 = this.keys[keyIndex]
                if (key2 == key) {
                    var oldValue = this.values[keyIndex]
                    // Remove item by updating previous to point to next
                    var nextIndex = this.nextIndexes[keyIndex] - 1
                    if (nextIndex >= 0) {
                        this.nextIndexes[previousIndex] = nextIndex + 1
                    } else {
                        this.nextIndexes[previousIndex] = 0
                    }
                    this.size--
                    return oldValue
                }
                previousIndex = keyIndex
                keyIndex = this.nextIndexes[keyIndex] - 1
            }
            return null
        }

        fun clear() {
            this.size = 0
            this.currentEntryIndex = 0
            this.currentIndex = this.bucketSize
            if (this.keyIndexes != null) {
                var i = 0
                while(i < this.keyIndexes.length()) {
                    this.keyIndexes[i] = 0
                    i++
                }
            }
        }

        fun containsKey(key: K): Bool {
            if (this.keyIndexes == null) {
                return false
            }
            var hash = key.hash()
            var index = hash % this.bucketSize
            var keyIndex = this.keyIndexes[index] - 1
            var entryIndex = this.findEntry(keyIndex, key)
            return entryIndex >= 0
        }

        fun containsValue(value: V): Bool {
            if (this.values == null) {
                return false
            }
            var i = 0
            while(i < this.currentEntryIndex) {
                var value2 = this.values[i]
                if (value2 == value) {
                    // Verify this entry is still valid by checking if its key exists
                    var key = this.keys[i]
                    if (this.containsKey(key)) {
                        return true
                    }
                }
                i++
            }
            return false
        }
    }
}