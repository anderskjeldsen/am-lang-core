
namespace Am.Lang 
{
    native class String {
        import Am.Collections
        import Am.IO

        override native fun hash(): UInt
        override fun toString(): String {
            return this
        }
        // TODO: change to length
        native fun getLength(): Int
        fun length(): Int {
            return this.getLength()
        }
        fun isEmpty(): Bool {
            return this.getLength() == 0
        }
        native fun print()
        native override fun equals(other: Object): Bool
        native op + (s: String): String
        native static fun fromBytes(bytes: UByte[], encoding: String): String
        native fun toBytes(encoding: String): UByte[]
        native fun indexOf(s: String): Int
        native fun lastIndexOf(s: String): Int
        native fun substring(start: UInt, length: UInt): String
        
        fun substringToEnd(start: UInt): String {
            var totalLength = this.getLength().toUInt()
            if (start >= totalLength) {
                return ""
            }
            var remainingLength = totalLength - start
            return this.substring(start, remainingLength)
        }
        
        fun indexOfAfter(s: String, startIndex: Int): Int {
            var searchText = this
            var searchLen = searchText.getLength()
            var patternLen = s.getLength()
            
            if (startIndex < 0 || startIndex >= searchLen || patternLen == 0) {
                return -1
            }
            
            var i = startIndex
            while (i <= (searchLen - patternLen)) {
                var found = true
                var j = 0
                while (j < patternLen) {
                    if (searchText.characterAt((i + j).toUInt()) != s.characterAt(j.toUInt())) {
                        found = false
                        break
                    }
                    j++
                }
                if (found) {
                    return i
                }
                i++
            }
            return -1
        }

        native private fun characterAtNative(index: UInt): UShort
        fun characterAt(index: UInt): UShort {
            if (index >= this.getLength().toUInt()) {
                throw new IndexOutOfBoundsException(index.toInt(), this.length().toUInt())
            }
            return this.characterAtNative(index)
        }



        fun endsWith(s: String): Bool {
            return this.lastIndexOf(s) == (this.getLength() - s.getLength()).toUInt()
        }

        fun split(character: UShort): String[] {
            var result = List<String>.newList<String>()
            var sb = new StringBuilder()
            var len = this.getLength()
            var i = 0UI
            while(i < len) {
                var c = this.characterAt(i)
                if (c == character) {
                    result.add(sb.toString())
                    sb.clear()
                } else {
                    sb.addChar(c)
                }
                i++
            }
            if (sb.getLength() > 0) {
                result.add(sb.toString())
            }
            return result.toArray()
        }
        
        fun splitByString(separator: String): String[] {
            var result = List<String>.newList<String>()
            var separatorLen = separator.getLength()
            
            if (separatorLen == 0) {
                // If separator is empty, return array with original string
                result.add(this)
                return result.toArray()
            }
            
            var lastIndex = 0
            var currentIndex = this.indexOf(separator)
            
            while (currentIndex >= 0) {
                // Add the substring before the separator
                var partLength = (currentIndex - lastIndex).toUInt()
                if (partLength > 0UI) {
                    result.add(this.substring(lastIndex.toUInt(), partLength))
                } else {
                    result.add("")
                }
                
                // Move past the separator
                lastIndex = currentIndex + separatorLen
                currentIndex = this.indexOfAfter(separator, lastIndex)
            }
            
            // Add the remaining part after the last separator
            var remainingLength = (this.getLength() - lastIndex).toUInt()
            if (remainingLength > 0UI) {
                result.add(this.substring(lastIndex.toUInt(), remainingLength))
            } else {
                result.add("")
            }
            
            return result.toArray()
        }

        fun println() {
            var s = this + "\n"
            s.print()
        }

        fun toUpperCase(): String {
            var sb = new StringBuilder()
            var len = this.getLength()
            var i = 0UI
            while(i < len) {
                var c = this.characterAt(i)
                // Convert lowercase letters to uppercase
                if (c >= 97US && c <= 122US) { // 'a' to 'z'
                    var upperC = c - 32US // Convert to uppercase
                    sb.addChar(upperC)
                } else {
                    sb.addChar(c)
                }
                i++
            }
            return sb.toString()
        }

        fun toLowerCase(): String {
            var sb = new StringBuilder()
            var len = this.getLength()
            var i = 0UI
            while(i < len) {
                var c = this.characterAt(i)
                // Convert uppercase letters to lowercase
                if (c >= 65US && c <= 90US) { // 'A' to 'Z'
                    var lowerC = c + 32US // Convert to lowercase
                    sb.addChar(lowerC)
                } else {
                    sb.addChar(c)
                }
                i++
            }
            return sb.toString()
        }

        fun trim(): String {
            var len = this.getLength().toUInt()
            if (len == 0UI) {
                return this
            }
            
            // Find start index (skip whitespace from beginning)
            var start = 0UI
            while(start < len) {
                var c = this.characterAt(start)
                if (c != 32US && c != 9US && c != 10US && c != 13US) { // space, tab, newline, carriage return
                    break
                }
                start++
            }
            
            // If all characters are whitespace
            if (start == len) {
                return ""
            }
            
            // Find end index (skip whitespace from end)
            var end = len - 1UI
            while(end > start) {
                var c = this.characterAt(end)
                if (c != 32US && c != 9US && c != 10US && c != 13US) { // space, tab, newline, carriage return
                    break
                }
                end--
            }
            
            // Return substring without leading/trailing whitespace
            // Break down the calculation to avoid operator precedence issues
            var lengthPart = end - start
            var trimmedLength = lengthPart + 1UI
            return this.substring(start, trimmedLength)
        }
        
        fun startsWith(prefix: String): Bool {
            var prefixLen = prefix.getLength().toUInt()
            var thisLen = this.getLength().toUInt()
            
            // Empty prefix should always return true
            if (prefixLen == 0UI) {
                return true
            }
            
            // If prefix is longer than this string, it cannot be a prefix
            if (prefixLen > thisLen) {
                return false
            }
            
            // Check each character
            var i = 0UI
            while(i < prefixLen) {
                if (this.characterAt(i) != prefix.characterAt(i)) {
                    return false
                }
                i++
            }
            
            return true
        }
        
        // File operations
        fun writeToFile(filename: String) {
            var file = new File(filename)
            var fileStream = new FileStream(file, FileAccess.readWriteTruncate)
            var textStream = new TextStream(fileStream)
            textStream.writeString(this)
        }
        
        static fun readFromFile(filename: String): String {
            var file = new File(filename)
            var fileStream = new FileStream(file, FileAccess.readOnly)
            var textStream = new TextStream(fileStream)
            return textStream.readString()
        }
        
        static fun join(strings: String[], separator: String): String {
            if (strings.length() == 0) {
                return ""
            }
            
            if (strings.length() == 1) {
                return strings[0]
            }
            
            var sb = new StringBuilder()
            var i = 0
            var maxIndex = strings.length() - 1
            
            while (i <= maxIndex) {
                sb.add(strings[i])
                if (i < maxIndex) {
                    sb.add(separator)
                }
                i++
            }
            
            return sb.toString()
        }
    }
}

