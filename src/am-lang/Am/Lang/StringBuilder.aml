
namespace Am.Lang 
{
    class StringBuilder {

        import Am.Collections
        
        private var encoding: String = "UTF-8"
        private var buffer: List<UByte> = List<UByte>.newList<UByte>()

        override fun toString(): String {
            var byteArray = this.buffer.toArray()
            return String.fromBytes(byteArray, this.encoding)
        }

        fun getLength(): UInt {
            return this.buffer.getSize().toUInt()
        }

//        native fun getLength(): Int
        op + (s: String): StringBuilder {
            var bytes = s.toBytes(this.encoding)
            var i = 0
            var len = bytes.length()
            var buf = this.buffer
            while(i < len) {
                buf.add(bytes[i])
                i++
            }
            return this
        }

        fun add(s: String): StringBuilder {
            var bytes = s.toBytes(this.encoding)
            var i = 0
            var len = bytes.length()
            var buf = this.buffer
            while(i < len) {
                buf.add(bytes[i])
                i++
            }
            return this
        }

        fun addChar(c: UShort) : StringBuilder {
            // TODO: convert to UTF-8
            this.buffer.add(c.toUByte()) // ditching the upper 8 bits for now.
            return this
        }

        fun addCharAt(index: UInt, c: UShort) : StringBuilder {
            // Insert character at specific index using List's insertAt method
            if (index >= this.buffer.getSize().toUInt()) {
                // If index is at or beyond end, just append
                this.addChar(c)
            } else {
                // Use List's insertAt for efficient insertion
                this.buffer.insertAt(index.toInt(), c.toUByte()) // TODO: proper UTF-8 conversion
            }
            return this
        }

        fun clear() {
            this.buffer.clear()
        }

    }
}

